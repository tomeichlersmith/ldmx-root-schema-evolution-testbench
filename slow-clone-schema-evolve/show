#!/bin/sh

echo "Building example programs..."
cmake -B build -S .
cmake --build build

# write/read/copy cycles work within schema versions
echo "Writing Header V1 to file..."
./build/write-v1
echo "Contents of v1-output:"
./build/read-v1 v1-output.root
echo "Copying v1-output with v1:"
./build/copy-v1 v1-output.root
echo "Contents of v1-copy-v1-output:"
./build/read-v1 v1-copy-v1-output.root

# write/read/copy cycles work within schema versions
echo "Writing Header V2 to file..."
./build/write-v2
echo "Contents of v2-output:"
./build/read-v2 v2-output.root
echo "Copying v2-output with v2:"
./build/copy-v2-clone-tree v2-output.root
echo "Contents of v2-copy-v2-output:"
./build/read-v2 v2-copy-v2-output.root

# forcing schema evolution during copying seems to require manually syncing the addresses
echo "Copying v1-output with v2 (using TTree::CloneTree):"
./build/copy-v2-clone-tree v1-output.root
echo "Copying v1-output with v2 (manual address sync):"
./build/copy-v2-manual v1-output.root

# look at contents of output copied files
echo "Contents of v1-output according to v2:"
./build/read-v2 v1-output.root
echo "Contents of v2-copy-clone-tree-v1-output according to v2:"
./build/read-v2 v2-copy-clone-tree-v1-output.root
echo "Contents of v2-copy-manual-v1-output according to v2:"
./build/read-v2 v2-copy-manual-v1-output.root

# if output file is written by v2 its not readable by v1
echo "Contents of v2-copy-clone-tree-v1-output according to v1:"
./build/read-v1 v2-copy-clone-tree-v1-output.root
echo "Contents of v2-copy-manual-v1-output according to v1:"
./build/read-v1 v2-copy-manual-v1-output.root
